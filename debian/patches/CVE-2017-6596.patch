From: Thomas Tsai <thomas@nchc.org.tw>
From: Hugo Lefeuvre <hle@debian.org>
Subject: Fix heap-based buffer overflow vulnerability CVE-2017-6596
 We add checks to make sure that enough memory was allocated for bitmap
 by calloc() before using it.

 Adapted for v0.2.48:
  * handle duplicated code in src/chkimg.c and src/restore.c
  * return meaningful error message

Origin: upstream, https://github.com/Thomas-Tsai/partclone/commit/2d6bcfd8016dc6090090934bab71c663d9a4d36d
Bug: https://github.com/Thomas-Tsai/partclone/issues/91
Bug-Debian: http://bugs.debian.org/857966
--- a/src/main.c	2017-04-27 15:08:32.514217275 +0200
+++ b/src/main.c	2017-04-27 15:09:18.654525010 +0200
@@ -26,6 +26,7 @@
 #include <string.h>
 #include <unistd.h>
 #include <pthread.h>
+#include <malloc.h>
 
 /**
  * progress.h - only for progress bar
@@ -117,6 +118,7 @@
     char		bitmagic_r[8]="00000000";/// read magic string from image
     int			cmp;			/// compare magic string
     unsigned long	*bitmap;		/// the point for bitmap data
+    unsigned long long  memsize = 0;
     int			debug = 0;		/// debug or not
     unsigned long	crc = 0xffffffffL;	/// CRC32 check code for writint to image
     unsigned long	crc_ck = 0xffffffffL;	/// CRC32 check code for checking
@@ -241,8 +243,10 @@
 
         /// alloc a memory to restore bitmap
         bitmap = (unsigned long*)calloc(sizeof(unsigned long), LONGS(image_hdr.totalblock));
-        if(bitmap == NULL){
-            log_mesg(0, 1, 1, debug, "%s, %i, ERROR:%s", __func__, __LINE__, strerror(errno));
+        memsize = sizeof(unsigned long) * LONGS(image_hdr.totalblock);
+
+        if ((bitmap == NULL) || (malloc_usable_size(bitmap) < memsize)) {
+            log_mesg(0, 1, 1, debug, "%s, %i, not enough memory\n", __func__, __LINE__);
         }
 
         log_mesg(2, 0, 0, debug, "initial main bitmap pointer %i\n", bitmap);
@@ -291,8 +295,10 @@
 
         /// alloc a memory to restore bitmap
         bitmap = (unsigned long*)calloc(sizeof(unsigned long), LONGS(image_hdr.totalblock));
-        if(bitmap == NULL){
-            log_mesg(0, 1, 1, debug, "%s, %i, ERROR:%s", __func__, __LINE__, strerror(errno));
+        memsize = sizeof(unsigned long) * LONGS(image_hdr.totalblock);
+
+        if ((bitmap == NULL) || (malloc_usable_size(bitmap) < memsize)) {
+            log_mesg(0, 1, 1, debug, "%s, %i, not enough memory\n", __func__, __LINE__);
         }
 
         /// check the image magic
@@ -333,8 +339,10 @@
 
         /// alloc a memory to restore bitmap
         bitmap = (unsigned long*)calloc(sizeof(unsigned long), LONGS(image_hdr.totalblock));
-        if(bitmap == NULL){
-            log_mesg(0, 1, 1, debug, "%s, %i, ERROR:%s", __func__, __LINE__, strerror(errno));
+        memsize = sizeof(unsigned long) * LONGS(image_hdr.totalblock);
+
+        if ((bitmap == NULL) || (malloc_usable_size(bitmap) < memsize)) {
+            log_mesg(0, 1, 1, debug, "%s, %i, not enough memory\n", __func__, __LINE__);
         }
 
         log_mesg(2, 0, 0, debug, "initial main bitmap pointer %i\n", bitmap);
@@ -366,8 +374,10 @@
 
         /// alloc a memory to restore bitmap
         bitmap = (unsigned long*)calloc(sizeof(unsigned long), LONGS(image_hdr.totalblock));
-        if(bitmap == NULL){
-            log_mesg(0, 1, 1, debug, "%s, %i, ERROR:%s", __func__, __LINE__, strerror(errno));
+        memsize = sizeof(unsigned long) * LONGS(image_hdr.totalblock);
+
+        if ((bitmap == NULL) || (malloc_usable_size(bitmap) < memsize)) {
+            log_mesg(0, 1, 1, debug, "%s, %i, not enough memory\n", __func__, __LINE__);
         }
 
         log_mesg(2, 0, 0, debug, "initial main bitmap pointer %i\n", bitmap);
--- a/src/partclone.c	2017-04-27 15:08:32.514217275 +0200
+++ b/src/partclone.c	2017-04-27 15:08:32.514217275 +0200
@@ -543,6 +543,13 @@
     r_size = read_all(ret, buffer, sizeof(image_head), opt);
     if (r_size == -1)
         log_mesg(0, 1, 1, debug, "read image_hdr error\n");
+
+    if (image_hdr->usedblocks > image_hdr->totalblock)
+        log_mesg(0, 1, 1, debug, "usedblocks larger than total block error\n");
+
+    if (image_hdr->block_size * image_hdr->totalblock > image_hdr->device_size )
+        log_mesg(0, 0, 1, debug, "device size not match block count\n");
+
     memcpy(image_hdr, buffer, sizeof(image_head));
     free(buffer);
     dev_size = (unsigned long long)(image_hdr->totalblock * image_hdr->block_size);
--- a/src/chkimg.c	2017-04-27 15:08:32.514217275 +0200
+++ b/src/chkimg.c	2017-04-27 15:09:53.706771416 +0200
@@ -26,6 +26,7 @@
 #include <unistd.h>
 #include <getopt.h>
 #include <pthread.h>
+#include <malloc.h>
 #include "version.h"
 
 /**
@@ -172,6 +173,7 @@
     char		bitmagic_r[8];		/// read magic string from image
     int			cmp;			/// compare magic string
     unsigned long	*bitmap;		/// the point for bitmap data
+    unsigned long long  memsize = 0;
     int			debug = 0;		/// debug or not
     unsigned long	crc = 0xffffffffL;	/// CRC32 check code for writint to image
     unsigned long	crc_ck = 0xffffffffL;	/// CRC32 check code for checking
@@ -263,8 +265,11 @@
 
     /// alloc a memory to restore bitmap
     bitmap = (unsigned long*)calloc(sizeof(unsigned long), LONGS(image_hdr.totalblock));
-    if(bitmap == NULL){
-        log_mesg(0, 1, 1, debug, "%s, %i, ERROR:%s", __func__, __LINE__, strerror(errno));
+
+    memsize = sizeof(unsigned long) * LONGS(image_hdr.totalblock);
+       
+    if ((bitmap == NULL) || (malloc_usable_size(bitmap) < memsize)) {
+        log_mesg(0, 1, 1, debug, "%s, %i, not enough memory\n", __func__, __LINE__);
     }
 
     log_mesg(2, 0, 0, debug, "initial main bitmap pointer %lli\n", bitmap);
--- a/src/restore.c	2017-04-27 15:08:32.514217275 +0200
+++ b/src/restore.c	2017-04-27 15:10:10.002889455 +0200
@@ -25,6 +25,7 @@
 #include <string.h>
 #include <unistd.h>
 #include <pthread.h>
+#include <malloc.h>
 
 /**
  * progress.h - only for progress bar
@@ -70,6 +71,7 @@
     char		bitmagic_r[8];		/// read magic string from image
     int			cmp;			/// compare magic string
     unsigned long	*bitmap;		/// the point for bitmap data
+    unsigned long long  memsize = 0;
     int			debug = 0;		/// debug or not
     unsigned long	crc = 0xffffffffL;	/// CRC32 check code for writint to image
     unsigned long	crc_ck = 0xffffffffL;	/// CRC32 check code for checking
@@ -179,8 +181,11 @@
 
 	    /// alloc a memory to restore bitmap
 	    bitmap = (unsigned long*)calloc(sizeof(unsigned long), LONGS(image_hdr.totalblock));
-	    if(bitmap == NULL){
-		log_mesg(0, 1, 1, debug, "%s, %i, ERROR:%s", __func__, __LINE__, strerror(errno));
+
+            memsize = sizeof(unsigned long) * LONGS(image_hdr.totalblock);
+       
+            if ((bitmap == NULL) || (malloc_usable_size(bitmap) < memsize)) {
+                log_mesg(0, 1, 1, debug, "%s, %i, not enough memory\n", __func__, __LINE__);
 	    }
 
 	    /// check the file system
